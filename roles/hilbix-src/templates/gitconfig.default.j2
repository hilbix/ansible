[user]
	name = {{ name }}
	email = {{ email }}
[init]
	defaultBranch = {{ defaultbranch | d(master) }}
[push]
	default = simple
[remote-hg]
	hg-git-compat = true
[tig]
	show-rev-graph = yes
[alias]
	confirm = "!LC_ALL=C.UTF-8 bash -c  '{\n[ false != \"$1\" ] || exit;\nprintf '\\''%q:'\\'' \"${1%%.*}\" && printf '\\'' %q'\\'' \"${@:2}\" && printf '\\'' [y/n]? '\\'' &&\nread -sn1 ans &&\ncase \"$ans\" in ([yY]) printf '\\''Yes\\n'\\''; exit 0;; esac;\nprintf '\\''No\\n'\\'';\n} >&2;\nexit 1;' --"
	mirror = "!LC_ALL=C.UTF-8 bash -c  'DIR=\"$(git config --local --get mirror.dir 2>/dev/null)\" ||\nDIR=\"$(git top git config --get mirror.dir 2>/dev/null)\"\nASK=\"git confirm\";\nwhile\tcase \"$1\" in\n\t(-y)\tASK=:;;\n\t(*)\tfalse;;\n\tesac;\ndo shift; done;\ncase \"$#:$1\" in (1:.) set -- \"${DIR:-\"$(readlink -m \"$HOME/gitmirror\")\"}\" || exit;; esac;\ncase \"$#\" in\n(0)\t[ -z \"$DIR\" ] || { set -- \"$DIR\" && $ASK mirror.\"$DIR\".default use \"$DIR\" || exit; }; false;;\n(1)\tNEW=\"$(readlink -m -- \"$1\")\" && [ ! -e \"$NEW\" -o -d \"$NEW\" ] || { printf '\\''not usable: %q\\n'\\'' \"$1\" >&2; exit 1; };\n\tTOP=\"$(git top)\" || exit;\n\tcase \"$NEW\" in (\"$TOP\"|\"$TOP/\"*) printf '\\''target must be outside of git tree: %q\\n'\\'' \"$TOP\" >&2; exit 1;; esac;\n\tset -- \"$NEW\";\n\tif [ -z \"$DIR\" ];\n\tthen\n\t\t$ASK mirror.\"$NEW\".default set \"$NEW\" as default;\n\telif\t[ \".$NEW\" = \".$DIR\" ];\n\tthen\n\t\tfalse;\n\telse\n\t\t$ASK mirror.\"$NEW\".default replace default \"$DIR\" with \"$NEW\";\n\tfi;;\n(*)\tfalse;;\nesac &&\n{\nset -- \"$NEW\";  # NOT redundant\n[ ! -e \"$NEW\" -o -d \"$NEW\" ] || { printf '\\''not usable: %q\\n'\\'' \"$1\" >&2; exit 1; };\ngit config --local mirror.dir \"$NEW\";\n}\n[ 1 = $# ] || { printf '\\''Usage: git mirror [-y] [DIR|.] -- recursively mirror submodule devtree into dir\\n'\\'' >&2; exit 42; };\n\n# see https://github.com/hilbix/tino/blob/46c7cf43d04ffd9bb9f647102408b0c5c9c1bcbf/datenschutz/security.md#verified\n\nMIRROR=\"$1\";\nif [ ! -d \"$MIRROR\" ]; then $ASK mirror.\"$MIRROR\".create create \"$MIRROR/\" && mkdir -p \"$MIRROR\" || exit; fi;\n\ngit-do() { HOME=\"$MIRROR\" GIT_CONFIG_NOSYSTEM=1 git \"$@\"; }\n\ngit-all()\n{\ngit-do \"$@\";\ngit-do submodule -q foreach --recursive \"git $(printf '\\'' %q '\\'' \"$@\")\";\n}\n\nOOPS()\n{\n{\nprintf '\\''\\nOOPS:'\\''\nprintf '\\'' %q'\\'' \"$@\";\nprintf '\\''\\n\\n'\\''\n} >&2;\nexit 23;\n}\n\no-git-all()\n{\ngit-all \"$@\" || OOPS failed: \"$@\"\n}\n\ncleanup()\n{\n{\n\"$@\";\necho \"#END#\"$'\\''\\t'\\''\"$?\";\n} 2>&1 |\n{\nret=;\nwhile IFS=$'\\''\\t'\\'' read -r a b c;\ndo\n\tret=;\n\tif [ -z \"$b$c\" ]\n\tthen\n\t\tb=\"${a%% *}\";\n\t\tc=\"${a#\"$b\"}\";\n\t\tcase \"$b $c\" in\n\t\t('\\''To '\\''*)\tprintf o; targ=\"${c#\"$MIRROR/git/\"}\"; continue;;\n\t\t('\\''Done '\\'')\tcontinue;;\n\t\tesac;\n\telse\n\t\tcase \"$a\" in\n\t\t('\\''#END#'\\'')\tret=\"$b\"; continue;;\n\t\t('\\''='\\'')\t\tprintf _; continue;;\n\t\t('\\''*'\\'')\t\tprintf +; continue;;\n\t\t('\\'' '\\'')\t\tprintf u; continue;;\n\t\t('\\''+'\\'')\t\tprintf F; continue;;\n\t\tesac;\n\tfi\n\tprintf '\\''\\n'\\'';\n\tOOPS unexpected output: \"$a\" -- \"$b\" -- \"$c\";\ndone;\nprintf '\\''\\n'\\'';\ncase \"$ret\" in\n('\\'''\\'')\tOOPS \"missing end marker\";;\n(0)\treturn 0;;\n(*)\treturn 1;;\nesac;\n}\n}\n\n# 1st: Create the \".insteadOf\" entries, using the mirror directory\nMIRROR=\"$MIRROR/nope\" git-all remote get-url --push origin |\nsed -n -e '\\''s/:[^/].*$/:/p'\\'' -e '\\''s!\\([^/]\\)/[^/].*$!\\1/!p'\\'' |\nsort -u |\nwhile read -r a; do\n  b=\"${a/:/}\"; b=\"${b/\\/\\//_}\"; b=\"${b//:/_}\";\n  HOME=\"$MIRROR\" git config --global \"url.$MIRROR/git/${b%/}/.insteadOf\" \"$a\";\ndone;\n\n# 2nd: Create the bare repositories for storage in it\nMIRROR=\"$MIRROR/nope\" git-all remote get-url --push origin |\nwhile read -r a; do\n  b=\"${a/:/}\"; b=\"${b/\\/\\//_}\"; b=\"${b//:/_}\";\n  [ -d \"$MIRROR/git/$b\" ] || git-do init --bare \"$MIRROR/git/$b\";\ndone;\n\n#git-do config --global push.default current;\ngit-do config --global push.default nothing;\n\n# forces an update the mirror to act as \"origin\"\nprintf '\\''P'\\'';\ncleanup o-git-all push --force --porcelain origin '\\''refs/remotes/origin/*:refs/heads/*'\\'' '\\''refs/tags/*:refs/tags/*'\\''\n\n# Also \"backup\" current local branches\n# XXX TODO XXX T.B.D.\n# To safe:  refs/*:refs/host/$(hostname -f)/$LOCATION/*\n#git-all push --force --porcelain origin \"refs/stash/*:refs/stash/*\";\n#git-all push --quiet --porcelain origin '\\''refs/remotes/*:refs/mirror/remotes/*'\\'';\n#git-all push --quiet --porcelain origin \"refs/heads/*:refs/host/$(hostname -f)/*\";\n\n# Now check for inconsistencies\n# This should not output anything!\n\nprintf '\\''B'\\'';\ncleanup git-all push --porcelain origin '\\''refs/remotes/origin/*:refs/heads/*'\\'' ||\nOOPS try: '\\''git remote update -p && git submodule --recursive foreach git remote update -p'\\'';\n\nprintf '\\''T'\\'';\ncleanup git-all push  --porcelain origin \"refs/tags/*:refs/tags/*\" ||\nOOPS tags are inconsistent.  You must manually repair this.;\n\necho \"WARNING: Mirroring is preliminary (and terribly incomplete)\"' --"
	amend = commit --amend
	amit = commit --amend -C HEAD
	adate = "!LC_ALL=C.UTF-8 bash -c  'export LC_ALL=C; TZ=UTC printf -vd \"%(%a, %d %b %Y %T %z)T\" \"${1:--1}\"; GIT_COMMITTER_DATE=\"$d\" git commit --amend --no-edit' --"
	bvv = branch -avv
	bv = "!LC_ALL=C.UTF-8 bash -c  'for a; do git config --local --unset ignore.bv \"$a\"; done;\n{\ngit config --get-all ignore.bv | sed '\\''s/^/d/'\\'';\ngit branch -avv | sed '\\''s/^/x/'\\'';\n} |\ngawk '\\''\n/^d/\t\t\t\t\t\t\t{ a=substr($0,2); ign[a]=1; b=a; sub(/[^/]*$/,\"\",b); c=substr($0,2+length(b)); if (b==\"\") b=\"(local)\"; m[b]=\"ignored\"; f[b]=\"branch:\"; k[b]=k[b] \" \" c; next }\n$2==\"(detached\" && $3==\"from\" && $4==$5\")\"\t\t{ $2=\"HEAD\"; $3=$5; }\n$2==\"(HEAD\" && $3==\"detached\" && $4==\"at\" && $5==$6\")\"\t{ $2=\"HEAD\"; $3=$6; }\n$3!=\"->\"\t{\n\t\tm[$3]=m[$3] substr($1,2);\n\t\tsub(/^remotes\\//,\"/\",$2);\n\t\tif (ign[$2]) next;\n\t\tif (!f[$3])\n\t\t\t{\n\t\t\tf[$3]=$2;\n\t\t\tif (length($2)>mx) mx=length($2);\n\t\t\t}\n\t\telse\t{\n\t\t\tl=length($2)-length(f[$3]);\n\t\t\tif (substr($2,l)==\"/\"f[$3]) $2=substr($2,1,l);\n\t\t\tk[$3]=k[$3] \" \" $2;\n\t\t\t}\n\t\t}\nEND\t{\n\tfor (a in f)\n\t\tprintf(\"x%-1s %s %-*s %s\\n\", m[a], a, (length(m[a])<2 ? mx : 0), f[a], substr(k[a],2));\n\t}'\\'' |\nsort -bk2 |\nsed '\\''s/^x//'\\''' --"
	tv = "!LC_ALL=C.UTF-8 bash -c  'for a; do git config --local --unset ignore.tv \"$a\"; done;\n{\nwhile read -ru6 tag; do printf '\\''%s\\t%s\\n'\\'' \"$(git rev-parse \"refs/tags/$tag\" || echo .)\" \"$tag\"; done 6< <(git tag --no-column);\nwhile read -ru6 n;\ndo\n\tprintf '\\''/%q/'\\'' \"$n\" >&2;\n\tgit config --get-all ignore.tv | fgrep -qx \"/$n/\" && { printf '\\'':ign '\\'' >&2; continue; }\n\t{\n\ttrap '\\''printf \"try: git tv.ign /%q/\\n\" \"$n\" >&2; exit 1'\\'' SIGINT;\n\tif\tgit ls-remote --tags \"$n\" 2>/dev/null;\n\tthen\n\t\tprintf '\\'':ok '\\'' >&2;\n\telse\n\t\tprintf '\\''=%s '\\'' $? >&2\n\tfi;\n\t} |\n\tgrep -vG '\\''\\^{}$'\\'' |\n\tgawk -F'\\''\\t'\\'' -vN=\"$n\" '\\''{ sub(/^[^/]*\\/[^/]*/,\"\",$2); print $1 \"\\t/\" N $2 }'\\'';\ndone 6< <(git remote);\necho >&2;\n} |\nsort -r |\ngawk '\\''\n\t{\n\tif (!f[$1])\t{ f[$1]=$2; if (mx<length($2)) mx=length($2); }\n\telse\t\t{ l=length($2)-length(f[$1]);\n\t\t\t  if (\"/\"f[$1] != substr($2,l)) l=length($2);\n\t\t\t  m[$1]=m[$1] \" \" substr($2,0,l);\n\t\t\t}\n\t}\nEND\t{ for (a in f) printf(\"%s %-*s %s\\n\", a, mx, f[a], m[a]); }\n'\\'' |\nsort' --"
	check = diff --check
	contained = "!LC_ALL=C.UTF-8 bash -c  '[ -n \"$(git branch --list --contains \"${*-HEAD}\" 2>/dev/null | sed -e \"s/^..//\" -e \"/^(/d\")\" ] && exit; printf \"FAIL: %q is not on a branch\\\\n\" \"${*-HEAD}\" >&2; exit 1' --"
	co = !git contained && git checkout
	empty = "!LC_ALL=C.UTF-8 bash -c  '# Do not remove double spaces in following, else '\\''git fsck'\\'' fails.  Is this the shortest possible empty commit?\ngit tag -- \"${1:-empty}\" \"$(git hash-object -t commit --stdin -w <<<\"tree $(git hash-object -wt tree /dev/null)\"$'\\''\\nauthor  <> 0 +0000\\ncommitter  <> 0 +0000'\\'')\"' --"
	ff = merge --ff-only --
	pager = "!pager() { cd \"$GIT_PREFIX\" && git -c color.status=always -c color.ui=always \"$@\" 2>&1 | less -XFR; }; pager"
	pageat = "!pager() { at=\"$1\" && shift && cd \"$GIT_PREFIX\" && git -c color.status=always -c color.ui=always \"$@\"  2>&1 | less -XFRp \"$at\"; }; pager"
	tree = !cd \"$GIT_PREFIX\" && git pager log --color=always --graph --oneline --decorate --all
	ls = !cd \"$GIT_PREFIX\" && git pager log --color=always --graph --oneline --decorate
	ll = !cd \"$GIT_PREFIX\" && git pager log --color=always --graph --oneline --decorate --numstat
	la = !cd \"$GIT_PREFIX\" && git pager log --color=always --graph -u --decorate
	st = !cd \"$GIT_PREFIX\" && git pager status
	isclean = "!LC_ALL=C.UTF-8 bash -c  'ok=\"$(git status --porcelain)\" && [ -z \"$ok\" ] && exit; printf \"${@:-$'\\''not clean\\n'\\''}\"; exit 1' --"
	ss = !cd \"$GIT_PREFIX\" && git pager submodule summary
	su = "!LC_ALL=C.UTF-8 bash -c  'cd \"$GIT_PREFIX\" || exit;\nargs='\\'''\\'';\n[ 0 = $# ] || printf -vargs \" %q\" \"$@\";\ngit pager submodule -q foreach '\\''git sane-submodule-update-from-submodule-foreach \"$toplevel\" \"$path\" \"$name\" \"$sha1\"'\\''\"$args\"' --"
	sane-submodule-update-from-submodule-foreach = "!LC_ALL=C.UTF-8 bash -c  'top=\"$1\";\npat=\"$2\";\nnam=\"$3\";\nsha=\"$4\";\nshift 4 || exit;\nargs=();\nrecurse=false;\nignore=false;\nquiet=false;\ndirt='\\''\\n'\\'';\nwhile\tcase \"$1\" in\t# I am lazy\n\t-r*|--r*)\targs+=(--recursive); recurse=:; true;;\n\t-i*|--i*)\targs+=(--ignore); ignore=true; true;;\n\t-q*|--q*)\targs+=(--quiet); quiet=true; dirt=; true;;\n\t-*)\t\techo \"Usage: git su [-recursive|-ignore|-quiet] [--] [path..]\" >&2; exit 42;;\n\t*)\t\tfalse;;\n\tesac;\ndo\n\tshift;\ndone;\ncase \"$1\" in\n--)\t\tshift;;\t\t\t# Do not harm others with my laziness.\nesac;\n[ 0 = $# ] && set -- '\\'''\\'';\n$quiet || printf \"Entering '\\''%q'\\''\\\\n\" \"$pat\";\n\n# Move this here to given $sha\nupdate()\n{\n# check if it is dirty, if so, do not change (as we are editing)\ngit isclean \"$dirt\"'\\''# MODULE not clean: %q/%q\\n'\\''\"$dirt\" \"$top\" \"$pat\" >&2 || { $ignore || exit; return 1; }\n# first try some ff to the given SHA\nwas=\"$(git rev-parse HEAD)\";\n[ \".$was\" = \".$sha\" ] && { $quiet || printf '\\''ok %q\\n'\\'' \"$sha\"; };\ngit ff \"$sha\" >/dev/null;\nat=\"$(git rev-parse HEAD)\";\n[ \".$at\" = \".$was\" ] || { printf '\\''fast forward %q..%q\\n'\\'' \"$was\" \"$at\"; };\n[ \".$at\" = \".$sha\" ] ||\nif\t# We are not at the wanted SHA, looks like it moves backward.\n\tgit contained \"$at\";\nthen\n\t# sha is contained in some branch, so we can safely move downward\n\tgit checkout --detach;\n\tgit reset --hard \"$sha\";\n\t[ \".$sha\" = \".$(git merge-base \"$sha\" \"$at\")\" ] && act=\"moved backward\" || act=jumped;\n\tprintf '\\''%s from %q\\n%s to   %q\\n'\\'' \"$act\" \"$at\" \"$act\" \"$sha\";\nfi;\n$recurse && exec git su \"${args[@]}\";\t# all is done, so we need not return\n};\n\nsubpath()\n{\nsub=\"${1#\"$2\"}\";\ncase \"$sub\" in\n('\\'''\\'')\treturn 0;\n(\"$1\")\t;;\n('\\''/'\\''*)\treturn 0;\nesac;\nfalse;\n};\n\nishit() { local a; for a; do [ -z \"$a\" ] || subpath \"$pat\" \"${a%/}\" && return; done; false; };\n\nishit \"$@\" && update;\n\nsubs=();\nfor a; do subpath \"$a\" \"$pat\" && [ -n \"$sub\" ] && subs+=\"${sub#/}\"; done;\n[ 0 = ${#subs[@]} ] && exit;\n\n#printf '\\''## %q\\n'\\'' \"${subs[@]}\";\ngit su \"${args[@]}\" -- \"${subs[@]}\";\n:;' --"
	wipe = "!LC_ALL=C.UTF-8 bash -c  'hi() { printf \"$@\" >&2; };\nnope() { e=$?; hi '\\''\\nnot wiped:'\\''; hi '\\'' %q'\\'' \"$@\"; hi '\\''\\n'\\''; exit $e; };\n[ -n \"$GIT_DIR\" ] && [ -d \"$GIT_DIR\" ] || nope missing \"$GIT_DIR\";\ngit fsck || nope damaged repo;\nhi '\\''This prunes refs/reflog/orphan NOW.  Type WIPE and Return: '\\'';\nfor a in W I P E '\\'''\\'';\ndo\n\tw=x;\n\tread -rn1 w && [ \".$a\" = \".$w\" ] || nope key \"$w\";\ndone;\nrm -rf \"$GIT_DIR/refs/original/\" \"$GIT_DIR/\"*_HEAD;\ngit reflog expire --expire-unreachable=now --all;\ngit fsck || nope damaged repo;\ngit gc --prune=now --aggressive;' --"
	up = status
	squash = rebase --interactive
	fixup = rebase --interactive --autosquash
	amend-tag = "!f(){ [ 1 = $# ] || { echo \"amend-tag needs tag name\"; return 1; }; git tag -f -a -- \"$1\" \"$1^{}\"; }; f"
	find = "!LC_ALL=C.UTF-8 bash -c  'ARGS=;\nfor a in \"${@-.}\"; do ARGS=\"$ARGS)|($a\"; done;\ngit log -C -M -B --pretty=format:$'\\''\\t'\\''%h --name-status --all |\ngawk -vP=\"(${ARGS:3})\" '\\''\n/^[\\t]/\t{ sha=$1; next }\n$0 ~ P\t{ print sha \"\\t\" $0; ret=1 }\nEND\t{ exit 1-ret }'\\''' --"
	qf = "!LC_ALL=C.UTF-8 bash -c  'cd \"$(git dir /bin/pwd)\";\nx=\"$(find objects -type f | sort | md5sum)\";\ncmp -s quickfind.status.tmp <<<\"$x\" ||\n{\necho -n \"indexing ..\" >&2;\ngit log -C -M -B --pretty=format: --name-status --all | sort -k2 | sed '\\''/^$/d'\\'' | uniq -c > quickfind.list.tmp && echo \"$x\" > quickfind.status.tmp;\necho \" done\" >&2;\n};\negrep \"${@:-.}\" < quickfind.list.tmp;' --"
	exact = "!LC_ALL=C.UTF-8 bash -c  'HEAD=HEAD\nSUFFIX=\n[ -n \"$1\" ] || set -- -C \"$HEAD\" \"${@:2}\"\n[ 2 -le $# ] &&\ncase \"$1\" in\n(-c)\tshift; true;;\n(-C)\tshift; HEAD=\"${1:-$HEAD}\"; SUFFIX='\\''^'\\''; true;;\n(-m)\tshift; false;;\n(*)\tfalse;;\nesac && set -- \"$(git cat-file -p \"${ARGS[0]:-$HEAD}\" | sed '\\''0,/^$/d'\\'')\" \"${@:2}\";\n[ -z \"$2\" ] && set -- \"$1\" \"$(git rev-parse --verify \"$HEAD@{u}\" >/dev/null 2>&1 && echo \"$HEAD@{u}..\")$HEAD$SUFFIX\" \"${@:3}\";\n\n# This format hopefully never changes\ngit log --raw \"${@:2}\" |\n\n# Converts the log into some NUL terminated lines\n# Lines starting with a TAB are SHAs\n# as git commit messages never start with a TAB.\ngawk '\\''\n/^$/\t\t{ printf \"%c\", 0; next }\n/^commit /\t{ printf \"\\t%s\", $2 }\n/^    /\t\t{ sub(/^    /,\"\"); print }'\\'' |\n\n# Now search for the exact commit message\ngawk -vA=\"$1\"$'\\''\\n'\\'' '\\''\nBEGIN\t{ RS=sprintf(\"%c\",0) }\n/^[\\t]/\t{ sha=$1; next }\n$0==A\t{ print sha; ret=1 }\nEND\t{ exit 1-ret }'\\''' --"
	sdiff = "!LC_ALL=C.UTF-8 bash -c  'O=();\nA=();\nwhile\tx=\"$1\";\n\tshift;\ndo\n\tcase $x in\n\t-*)\tO+=(\"$x\");;\n\t*)\tA+=(\"$x^{}\");;\n\tesac;\ndone;\ng()\n{\ngit show \"${A[$1]}\" && return;\necho FAIL ${A[$1]};\ngit show \"${A[$2]}\";\n};\ndiff \"${O[@]}\" <(g 0 1) <(g 1 0)' --"
	udiff = !git sdiff -u
	bdiff = !git sdiff -b
	ddiff = !git pager udiff
	cdiff = "!cdiff() { git diff --color \"$@\" | perl /usr/share/doc/git/contrib/diff-highlight/diff-highlight | less -XFR; }; cdiff"
	submodules-register = "!LC_ALL=C.UTF-8 bash -c  '# Safely extract the submodule keys.  You must use -z, as following cannot be parsed line by line:\n#\tgit submodule add . xxx && git mv xxx $'\\''.\\nsubmodule.fake.path err\\n'\\''\n# It'\\''s good to always test with filenames which end on $'\\''\\n'\\'' and also contain some fakey expected lines.\n# Luckily, keys cannot contain $'\\''\\n'\\'' nor NUL.  For example, following shows, this is unsupported (exposes a git bug?):\n#\tgit submodule add URL $'\\''a\\nb'\\''\ngit config -f .gitmodules -z --get-regexp '\\''^submodule\\..*\\.path$'\\'' |\nsed -z '\\''s/\\n.*$//'\\'' | tr '\\''\\0'\\'' '\\''\\n'\\'' |\nwhile read -r key;\ndo\n\tsub=\"${key%.path}\";\n\tpth=\"$(git config -f .gitmodules --get \"$sub.path\")x\" &&\n\turl=\"$(git config -f .gitmodules --get \"$sub.url\")\" &&\n\tif\tpth=\"${pth%x};\t# protects against filenames with trailing $'\\''\\n'\\''\n\t\tbra=\"$(git config -f .gitmodules --get \"$sub.branch\")\" &&\n\t\t[ -n \"$bra\" ];\n\tthen\n\t\tgit submodule add -b \"$bra\" -- \"$url\" \"$pth\";\n\telse\n\t\tgit submodule add -- \"$url\" \"$pth\";\n\tfi;\ndone' --"
	fake-merge = "!LC_ALL=C.UTF-8 bash -c  'unset HAVE; declare -A HAVE;\nm=;\nP=();\na=false;\nc=false;\nfor b in HEAD \"$@\";\ndo\n\t[ .-a = \".$b\" ] && { a=:; continue; }\n\t[ .-c = \".$b\" ] && { c=:; continue; }\n\tp=\"$(git rev-parse --verify \"$b\")\" || { echo \"cannot interpret $b\" >&2; exit 1; };\n\t$a &&    GIT_AUTHOR_DATE=\"$(git show -s --format=%ai \"$p\")\" && export    GIT_AUTHOR_DATE && a=false;\n\t$c && GIT_COMMITTER_DATE=\"$(git show -s --format=%ci \"$p\")\" && export GIT_COMMITTER_DATE && c=false;\n\t[ -z \"${HAVE[\"$p\"]}\" ] || { echo \"WARN: ignore already seen commit $b\" >&2; continue; };\n\tHAVE[\"$p\"]=1;\n\tP+=(-p \"$p\");\n\tif [ -z \"$m\" ]; then m=\"Fake-Merge\"; else m=\"$m $b,\"; fi;\ndone;\nob=\"$(git write-tree)\" || { echo \"git-write-tree failed, aborting\" >&2; exit 1; };\ncc=\"$(git commit-tree \"${P[@]}\" -m \"${m:0:-1} into $(git rev-parse --abbrev-ref HEAD)\" \"$ob\")\" && git ff \"$cc\"' --"
	exec = "!exec "
	make = !exec make
	top = "!LC_ALL=C.UTF-8 bash -c  'GIT_DIR=\"$(git dir /bin/pwd)\";\nGIT_TOP=\"${GIT_DIR%%/.git/modules/*}\";\n[ \".$GIT_TOP\" != \".$GIT_DIR\" ] && cd \"$GIT_TOP\";\nunset GIT_DIR;\nexec \"${@:-/bin/pwd}\";' --"
	all = !tig --all
	tig = !tig --all
	run = "!f() { cd \"$GIT_PREFIX\" && exec \"$@\"; }; f"
	bash = "!f() { cd \"$GIT_PREFIX\" && exec bash -c \"${*:-set}\"; }; f"
	dir = !LC_ALL=C.UTF-8 bash -c  'cd \"${GIT_DIR:-\"$(git rev-parse --git-dir)\"}\" && exec \"${@:-\"$SHELL\"}\"' --
	hop = "!f() { git contained && git rev-parse --verify \"$*^{commit}\" && git checkout \"HEAD^{}\" && git reset --soft \"$*\" && git checkout \"$*\"; }; f"
	relate = "!LC_ALL=C.UTF-8 bash -c  'x=\"$1\";\ncase \"$#\" in\n0|1)\tgit for-each-ref --format=\"%(refname:short) %(upstream:short)\" refs;;\n*)\tshift; for a in \"$@\"; do echo \"$a\"; done;;\nesac |\nwhile read -r l r;\ndo\n\tprintf \"%24s %s\\\\n\" \"$(git rev-list --cherry-mark --dense --left-right --boundary --oneline \"${x:-${r:-HEAD}}...$l\" -- | sed \"s/^\\\\(.\\\\).*/\\\\1/\" | sort | uniq -c | tr -d \" \" | tr \"\\\\n\" \" \")\" \"${x:-${r:-HEAD}}...$l\";\ndone;' --"
	dograph = "!graph(){ case \"$#:$3\" in 2:) r=\"HEAD...HEAD@{u}\";; 3:*...*) r=\"$3\";; 3:*) r=\"HEAD...$3\";; *) r=\"$3...$4\";; esac; r1=\"$(git rev-parse \"${r%%...*}\")\"; r2=\"$(git rev-parse \"${r##*...}\")\"; echo \"$r - $r1 - $r2\"; r1s=\" $(git rev-parse --short \"$r1\") \"; eval \"v=\\\"\\$$1\\\"\"; if [ \".$r1\" = \".$r2\" ]; then git pageat \"${v# }\" log --color=always $2 -1 \"$r1\"; else git pageat \"$v\" rev-list --color=always --cherry-mark --dense --left-right --boundary $2 --graph \"$r1...$r2\" --; fi; }; graph"
	graph = !git dograph r1 --pretty
	graph1 = !git dograph r1s --oneline
	bring = "!LC_ALL=C.UTF-8 bash -c  '[ -n \"$1\" ] || set -- \"$(mktemp --suffix=.bundle)\" \"${@:2}\";\n[ -n \"$2\" ] || set -- \"$1\" \"@{u}...\" \"${@:3}\";\ngit bundle create \"$@\" &&\nls -al \"$1\";' --"
	murx = "!LC_ALL=C.UTF-8 bash -c  '# I know the correct writing is \"murks\"\nSTDERR() { local e=$?; { printf %q \"$1\"; printf '\\'' %q'\\'' \"${@:2}\"; printf '\\''\\n'\\''; } >&2; return $e; };\nOOPS() { STDERR OOPS: \"$@\"; exit 23; };\n[ 0 = $# ] && set -- HEAD;\nmurx=\"$(git config --get murx.branch)\";\nmurx=\"${name:-murx}\";\nPARENTS=();\n# preset the \"murx\" branch as the first parent\nunset KNOWN; declare -A KNOWN;\nSHA=\"$(git rev-parse --verify \"$murx\" 2>/dev/null)\" && [ -n \"$SHA\" ] && PARENTS+=(-p \"$SHA\") && KNOWN[\"$SHA\"]=1;\n# Make \"git murx\" idempotent, so calling it repeatedly does just nothing\nwhile\tread -r parent sha && [ -n \"$parent$sha\" ];\ndo\n\tcase \"$parent\" in\n\t(parent)\tKNOWN[\"$sha\"]=1;;\n\tesac;\ndone < <(git cat-file -p \"$SHA\");\nlast=;\nfor a;\ndo\n\tp=\"$(git rev-parse --verify \"$a\")\" || STDERR ignoring SHA \"$a\" || continue;\n\t[ -z \"${KNOWN[\"$p\"]}\" ] || STDERR ignoring already present SHA \"$a\" \"$p\" || continue;\n\tKNOWN[\"$p\"]=1;\n\tPARENTS+=(-p \"$p\");\n\tlast=\"$p\";\ndone;\n[ -n \"$last\" ] || OOPS no usable SHAs found;\n# get the tree of the last SHA provided\ntree=\"$(git cat-file -p \"$last\" | sed -n '\\''1s/^tree //p'\\'')\";\n[ -n \"$tree\" ] || OOPS no usable tree found in \"$last\";\n# create \"murx\" merge from the given parents with the given tree\nMERGE=\"$(git commit-tree -m \"murx: $*\" \"${PARENTS[@]}\" \"$tree\")\" && git branch -f \"$murx\" \"$MERGE\" && printf '\\''# branch %q now at %q\\n'\\'' \"$murx\" \"$MERGE\"' --"
	condense = "!LC_ALL=C.UTF-8 bash -c  'STDERR() { local e=$?; { printf %q \"$1\"; printf '\\'' %q'\\'' \"${@:2}\"; printf '\\''\\n'\\''; } >&2; return $e; };\nOOPS() { STDERR OOPS: \"$@\"; exit 23; };\nif [ -z \"$1\" ];\nthen\n\tmurx=\"$(git config --get murx.branch)\";\n\tset -- \"${murx:-murx}\" \"${@:2}\";\nfi;\n[ -n \"$2\" ] || set -- \"$1\" \"$1{u}\" \"${@:3}\";\n[ 2 = $# ] || OOPS too many arguments: git condense branch parent: \"$@\";\nb=\"$(git rev-parse --verify \"$1\")\" && [ -n \"$b\" ] || OOPS invalid first arg \"$1\": \"$b\";\np=\"$(git rev-parse --verify \"$2\")\" && [ -n \"$p\" ] || OOPS invalid second arg \"$2\": \"$p\";\ntree=\"$(git cat-file -p \"$b\" | sed -n '\\''1s/^tree //p'\\'')\" && [ -n \"$tree\" ] || OOPS no usable tree found in \"$b\";\nSTDERR tree \"$tree\";\nMSG=;\ncnt=0;\nnr=0;\nunset COMMIT; declare -A COMMIT;\nunset WAS; declare -A WAS;\nSHAS=();\nCOMMIT[\"$p\"]=0;\nnext=\"$b\";\nwhile\t[ -n \"$next\" ] || OOPS did not reach \"$p\" from \"$b\"\n\t[ \".$next\" != \".$p\" ]\ndo\n\t[ 100 -gt \"$cnt\" ] || OOPS too many commits: stopping at \"$next\";\n\tCOMMIT[\"$next\"]=0;\n\tfirst=;\n\t{\n\tread -r head sha && [ tree = \"$head\" ] || OOPS invalid commit \"$next\";\n\tSTDERR next \"$next\" \"$sha\";\n\twhile\tread -r parent sha && [ -n \"$parent$sha\" ];\n\tdo\n\t\tcase \"$parent\" in\n\t\t(author|committer)\tcontinue;;\n\t\t(parent)\t\t;;\n\t\t(*)\t\t\tOOPS unknown header in commit object \"$next\": \"$parent\" \"$sha\";;\n\t\tesac\n\t\t[ -z \"$first\" ] && first=\"$sha\" && continue;\n\t\t[ 0 = \"${COMMIT[\"$sha\"]}\" ] && continue;\n\t\tlet nr++ || :;\n\t\tCOMMIT[\"$sha\"]=$nr;\n\tdone;\n\tc=\"$(cat)\";\t # useful use of cat\n\t# ignore repeated messages\n\t[ -z \"${WAS[\"$c\"]}\" ] && MSG=\"$MSG\"$'\\''\\n\\n-------\\n\\n'\\''\"$c\" && WAS[\"$c\"]=x;\n\t} < <(git cat-file -p \"$next\")\n\tlet cnt++ || :;\n\tnext=\"$first\";\ndone;\n[ 1 -le \"$cnt\" ] || OOPS nothing to do;\n# Now order COMMITs by their sequence.\n# Parent COMMITs are ignored (==0, their MSGs are gathered above).\nSHAS=();\nfor sha in \"${!COMMIT[@]}\";\ndo\n\tSHAS[${COMMIT[\"$sha\"]}]=\"$sha\";\ndone;\n# Create the merges in sequence of the SHAS\n# (which is ordered by COMMIT[] number)\nMERGES=(-p \"$p\");\nfor sha in \"${SHAS[@]}\";\ndo\n\tMERGES+=(-p \"$sha\");\ndone;\nMERGE=\"$(git commit-tree -m \"condensed $1 to $2$MSG\" \"${MERGES[@]}\" \"$tree\")\" || OOPS merge failed for tree \"$tree\": \"${MERGES[@]}\";\ngit branch -f \"$1\" \"$MERGE\" && printf '\\''# branch %q now at %q condensed from %q\\n'\\'' \"$1\" \"$MERGE\" \"$b\"' --"
	coff = "!LC_ALL=C.UTF-8 bash -c  'explicite=false;\nLIST=(\"$@\")\nif [ 0 = $# ];\nthen\n\texplicite=:\nfi\n# explicicte\n# pick our location\n# find next nearest branch (or take the given ones)\n# take the nearest one\n# check the tracking location of this branch' --"
	bff = !LC_ALL=C.UTF-8 bash -c  '' --
[alias "bv"]
	ign = "!LC_ALL=C.UTF-8 bash -c  'for a; do git config --local --get-all ignore.bv | fgrep -qx \"$a\" || git config --local --add ignore.bv \"$a\"; done' --"
[alias "tv"]
	ign = "!LC_ALL=C.UTF-8 bash -c  'for a; do git config --local --get-all ignore.tv | fgrep -qx \"$a\" || git config --local --add ignore.tv \"$a\"; done' --"
